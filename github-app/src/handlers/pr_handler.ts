import { Context } from "probot";
import axios from "axios";

// Types matching Backend API
interface Violation {
    rule_id: string;
    message: string;
    severity: "INFO" | "WARNING" | "BLOCKING";
    file_path: string;
    line_number: number;
    suggestion?: string;
    category: string;
}

interface ScanResponse {
    status: string;
    violations: Violation[];
    succeeded: boolean;
    summary: string;
    enforcement_mode: string;
}

export const handlePullRequest = async (context: Context<"pull_request">) => {
    const pr = context.payload.pull_request;
    const repo = context.repo();

    context.log.info(`Processing PR #${pr.number}`);

    // 1. Fetch changed files
    const filesResponse = await context.octokit.pulls.listFiles({
        owner: repo.owner,
        repo: repo.repo,
        pull_number: pr.number,
    });

    const filesToScan = filesResponse.data.map((f) => ({
        filename: f.filename,
        content: f.patch || "", // In a real app, we might fetch full content if patch is insufficient
        patch: f.patch,
    }));

    if (filesToScan.length === 0) {
        context.log.info("No files to scan.");
        return;
    }

    // Fetch config override if exists
    let configOverride: string | undefined;
    try {
        const configResponse = await context.octokit.repos.getContent({
            owner: repo.owner,
            repo: repo.repo,
            path: ".ai-guardrails.yaml",
            ref: pr.head.sha
        });

        if ('content' in configResponse.data && !Array.isArray(configResponse.data)) {
            configOverride = Buffer.from(configResponse.data.content, 'base64').toString();
        }
    } catch (e) {
        // No config found, ignore
    }

    // 1.5 Check for Copilot Usage via Commits
    let isCopilotGenerated = false;
    try {
        const commitsResponse = await context.octokit.pulls.listCommits({
            owner: repo.owner,
            repo: repo.repo,
            pull_number: pr.number,
        });

        isCopilotGenerated = commitsResponse.data.some(commit => {
            const msg = commit.commit.message.toLowerCase();
            return msg.includes("co-authored-by: copilot") ||
                msg.includes("co-authored-by: github <noreply@github.com>") ||
                msg.includes("generated by copilot");
        });

        if (isCopilotGenerated) {
            context.log.info("ü§ñ Copilot-generated code detected in PR commits.");
        }
    } catch (e) {
        context.log.warn("Failed to fetch commits for Copilot detection.");
    }

    // 1.6 Set Pending Status
    await context.octokit.repos.createCommitStatus({
        owner: repo.owner,
        repo: repo.repo,
        sha: pr.head.sha,
        state: "pending",
        context: "AI Guardrails",
        description: isCopilotGenerated ? "Scanning Copilot-generated code..." : "Scanning for violations..."
    });

    // 2. Call Backend API
    try {
        let backendUrl = process.env.BACKEND_URL || "http://127.0.0.1:8000/api/v1";

        // Robustness: Ensure URL ends with /api/v1
        if (!backendUrl.endsWith('/api/v1')) {
            // Avoid double slashes if user put trailing slash
            backendUrl = backendUrl.replace(/\/+$/, "") + "/api/v1";
        }


        const response = await axios.post<ScanResponse>(`${backendUrl}/scan`, {
            repo_full_name: `${repo.owner}/${repo.repo}`,
            pr_number: pr.number,
            commit_sha: pr.head.sha,
            files: filesToScan,
            config_override: configOverride,
            is_copilot_generated: isCopilotGenerated
        });

        const scanResult = response.data;

        // 3. Post Feedback & Status
        await context.octokit.repos.createCommitStatus({
            owner: repo.owner,
            repo: repo.repo,
            sha: pr.head.sha,
            state: scanResult.succeeded ? "success" : "failure",
            context: "AI Guardrails",
            description: scanResult.summary.substring(0, 140) // GitHub limit
        });

        if (scanResult.violations.length > 0) {

            // Post review comments
            const comments = scanResult.violations.map(v => ({
                path: v.file_path,
                line: v.line_number,
                body: `**[${v.severity}] ${v.rule_id}**: ${v.message}\n\n${v.suggestion ? `Suggestion: \`${v.suggestion}\`` : ""}`
            }));

            // Group into a review
            // Note: GitHub limit is approx 80 comments per review.
            // For prototype we'll take top 10 to avoid limits.
            const reviewComments = comments.slice(0, 10);

            try {
                // Attempt 1: Review with Inline Comments
                await context.octokit.pulls.createReview({
                    owner: repo.owner,
                    repo: repo.repo,
                    pull_number: pr.number,
                    event: scanResult.succeeded ? "COMMENT" : "REQUEST_CHANGES",
                    body: `## Guardrails Scan Results\n\n**Mode**: ${scanResult.enforcement_mode}\n\n${scanResult.summary}\n\n${scanResult.succeeded ? "‚úÖ Checks Passed" : "‚ùå Blocking Issues Found"}`,
                    comments: reviewComments
                });
            } catch (reviewError: any) {
                context.log.info(`Inline review failed (likely line mismatch), falling back to summary review: ${reviewError.message}`);

                // Detailed Body for the fallback review
                const violationDetails = scanResult.violations.map(v =>
                    `- **[${v.severity}] ${v.rule_id}** (${v.file_path}:${v.line_number}): ${v.message}`
                ).join("\n");

                // Attempt 2: Review WITHOUT Inline Comments (Body only)
                // This ensures we still BLOCK the PR (Request Changes) if needed
                await context.octokit.pulls.createReview({
                    owner: repo.owner,
                    repo: repo.repo,
                    pull_number: pr.number,
                    event: scanResult.succeeded ? "COMMENT" : "REQUEST_CHANGES",
                    body: `## Guardrails Scan Results (Summary)\n(Inline comments failed due to line mismatch - violations listed below)\n\n**Mode**: ${scanResult.enforcement_mode}\n\n${scanResult.summary}\n\n### üîç Violation Details\n${violationDetails}\n\n${scanResult.succeeded ? "‚úÖ Checks Passed" : "‚ùå Blocking Issues Found"}`
                });
            }
        } else {
            // Post success comment
            await context.octokit.issues.createComment({
                owner: repo.owner,
                repo: repo.repo,
                issue_number: pr.number,
                body: "## Guardrails Scan passed! ‚úÖ\nNo issues found.",
            });
        }

    } catch (error) {
        context.log.error(error, "Failed to scan code");

        // Set Failure Status on Error
        await context.octokit.repos.createCommitStatus({
            owner: repo.owner,
            repo: repo.repo,
            sha: pr.head.sha,
            state: "error",
            context: "AI Guardrails",
            description: "Scan failed due to internal error."
        });

        await context.octokit.issues.createComment({
            owner: repo.owner,
            repo: repo.repo,
            issue_number: pr.number,
            body: "‚ö†Ô∏è Guardrails Scan failed due to an internal error.",
        });
    }
};
