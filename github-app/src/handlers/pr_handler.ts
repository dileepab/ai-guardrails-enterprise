import { Context } from "probot";
import axios from "axios";

// Types matching Backend API
interface Violation {
    rule_id: string;
    message: string;
    severity: "INFO" | "WARNING" | "BLOCKING";
    file_path: string;
    line_number: number;
    suggestion?: string;
    category: string;
}

interface ScanResponse {
    status: string;
    violations: Violation[];
    succeeded: boolean;
    summary: string;
    enforcement_mode: string;
}

export const handlePullRequest = async (context: Context<"pull_request">) => {
    const pr = context.payload.pull_request;
    const repo = context.repo();

    context.log.info(`Processing PR #${pr.number}`);

    // 1. Fetch changed files
    const filesResponse = await context.octokit.pulls.listFiles({
        owner: repo.owner,
        repo: repo.repo,
        pull_number: pr.number,
    });

    const filesToScan = [];

    context.log.info(`Found ${filesResponse.data.length} changed files.`);

    // Filter out removed files and fetch content for modified/added files
    for (const f of filesResponse.data) {
        context.log.info(`File: ${f.filename}, Status: ${f.status}`);
        if (f.status === 'removed') continue;

        try {
            const contentResponse = await context.octokit.repos.getContent({
                owner: repo.owner,
                repo: repo.repo,
                path: f.filename,
                ref: pr.head.sha
            });

            // Decode content (GitHub returns base64)
            let content = "";
            if ('content' in contentResponse.data && !Array.isArray(contentResponse.data)) {
                content = Buffer.from(contentResponse.data.content, 'base64').toString();
            }

            filesToScan.push({
                filename: f.filename,
                content: content,
                patch: f.patch, // Keep patch for context if needed, but scan 'content'
            });
            context.log.info(`Successfully fetched content for ${f.filename}`);
        } catch (error: any) {
            context.log.warn(`Failed to fetch content for ${f.filename}: ${error.message}`);
        }
    }

    if (filesToScan.length === 0) {
        context.log.info("No files to scan.");
        // Post Success Status immediately so PR isn't stuck in "Pending"
        await context.octokit.repos.createCommitStatus({
            owner: repo.owner,
            repo: repo.repo,
            sha: pr.head.sha,
            state: "success",
            context: "AI Guardrails",
            description: "No relevant files changed. Scan skipped."
        });
        return;
    }

    // Fetch config override if exists
    let configOverride: string | undefined;
    try {
        const configResponse = await context.octokit.repos.getContent({
            owner: repo.owner,
            repo: repo.repo,
            path: ".ai-guardrails.yaml",
            ref: pr.head.sha
        });

        if ('content' in configResponse.data && !Array.isArray(configResponse.data)) {
            configOverride = Buffer.from(configResponse.data.content, 'base64').toString();
        }
    } catch (e) {
        // No config found, ignore
    }

    // 1.5 Check for Copilot Usage via Commits
    let isCopilotGenerated = false;
    try {
        const commitsResponse = await context.octokit.pulls.listCommits({
            owner: repo.owner,
            repo: repo.repo,
            pull_number: pr.number,
        });

        isCopilotGenerated = commitsResponse.data.some(commit => {
            const msg = commit.commit.message.toLowerCase();
            return msg.includes("co-authored-by: copilot") ||
                msg.includes("co-authored-by: github <noreply@github.com>") ||
                msg.includes("generated by copilot");
        });

        if (isCopilotGenerated) {
            context.log.info("ü§ñ Copilot-generated code detected in PR commits.");
        }
    } catch (e) {
        context.log.warn("Failed to fetch commits for Copilot detection.");
    }

    // 1.6 Set Pending Status
    await context.octokit.repos.createCommitStatus({
        owner: repo.owner,
        repo: repo.repo,
        sha: pr.head.sha,
        state: "pending",
        context: "AI Guardrails",
        description: isCopilotGenerated ? "Scanning Copilot-generated code..." : "Scanning for violations..."
    });

    // 2. Call Backend API
    try {
        let backendUrl = process.env.BACKEND_URL || "http://127.0.0.1:8000/api/v1";

        // Robustness: Ensure URL ends with /api/v1
        if (!backendUrl.endsWith('/api/v1')) {
            // Avoid double slashes if user put trailing slash
            backendUrl = backendUrl.replace(/\/+$/, "") + "/api/v1";
        }


        const response = await axios.post<ScanResponse>(`${backendUrl}/scan`, {
            repo_full_name: `${repo.owner}/${repo.repo}`,
            pr_number: pr.number,
            commit_sha: pr.head.sha,
            files: filesToScan,
            config_override: configOverride,
            is_copilot_generated: isCopilotGenerated
        });

        const scanResult = response.data;

        // 3. Post Feedback & Status
        context.log.info(`Updating commit status to: ${scanResult.succeeded ? "success" : "failure"}`);
        try {
            await context.octokit.repos.createCommitStatus({
                owner: repo.owner,
                repo: repo.repo,
                sha: pr.head.sha,
                state: scanResult.succeeded ? "success" : "failure",
                context: "AI Guardrails",
                description: scanResult.summary.substring(0, 140) // GitHub limit
            });
            context.log.info("Successfully updated commit status.");
        } catch (e: any) {
            context.log.error(`Failed to update commit status: ${e.message}`);
        }

        if (scanResult.violations.length > 0) {

            // Post review comments
            const comments = scanResult.violations.map(v => ({
                path: v.file_path,
                line: v.line_number,
                body: `**[${v.severity}] ${v.rule_id}**: ${v.message}\n\n${v.suggestion ? `Suggestion: \`${v.suggestion}\`` : ""}`
            }));

            // Group into a review
            // Note: GitHub limit is approx 80 comments per review.
            // For prototype we'll take top 10 to avoid limits.
            const reviewComments = comments.slice(0, 10);

            try {
                // Attempt 1: Review with Inline Comments
                await context.octokit.pulls.createReview({
                    owner: repo.owner,
                    repo: repo.repo,
                    pull_number: pr.number,
                    event: scanResult.succeeded ? "COMMENT" : "REQUEST_CHANGES",
                    body: `## Guardrails Scan Results\n\n**Mode**: ${scanResult.enforcement_mode}\n\n${scanResult.summary}\n\n${scanResult.succeeded ? "‚úÖ Checks Passed" : "‚ùå Blocking Issues Found"}`,
                    comments: reviewComments
                });
            } catch (reviewError: any) {
                context.log.info(`Inline review failed (likely line mismatch), falling back to summary review: ${reviewError.message}`);

                // Detailed Body for the fallback review
                const violationDetails = scanResult.violations.map(v =>
                    `- **[${v.severity}] ${v.rule_id}** (${v.file_path}:${v.line_number}): ${v.message}`
                ).join("\n");

                // Attempt 2: Review WITHOUT Inline Comments (Body only)
                // This ensures we still BLOCK the PR (Request Changes) if needed
                await context.octokit.pulls.createReview({
                    owner: repo.owner,
                    repo: repo.repo,
                    pull_number: pr.number,
                    event: scanResult.succeeded ? "COMMENT" : "REQUEST_CHANGES",
                    body: `## Guardrails Scan Results (Summary)\n(Inline comments failed due to line mismatch - violations listed below)\n\n**Mode**: ${scanResult.enforcement_mode}\n\n${scanResult.summary}\n\n### üîç Violation Details\n${violationDetails}\n\n${scanResult.succeeded ? "‚úÖ Checks Passed" : "‚ùå Blocking Issues Found"}`
                });
            }
        } else {
            // Post success comment
            await context.octokit.issues.createComment({
                owner: repo.owner,
                repo: repo.repo,
                issue_number: pr.number,
                body: "## Guardrails Scan passed! ‚úÖ\nNo issues found.",
            });
        }

    } catch (error) {
        context.log.error(error, "Failed to scan code");

        // Set Failure Status on Error
        await context.octokit.repos.createCommitStatus({
            owner: repo.owner,
            repo: repo.repo,
            sha: pr.head.sha,
            state: "error",
            context: "AI Guardrails",
            description: "Scan failed due to internal error."
        });

        await context.octokit.issues.createComment({
            owner: repo.owner,
            repo: repo.repo,
            issue_number: pr.number,
            body: "‚ö†Ô∏è Guardrails Scan failed due to an internal error.",
        });
    }
};
